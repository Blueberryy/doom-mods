// TooltipListMenu -- a drop-in replacement for ListMenu with tooltip support.
// Released under the MIT license; see COPYING.md for details.
//
// To use this, declare your list menu in MENUDEF as normal, but add:
//   class TF_TooltipListMenu
// You can then use the "Tooltip", "TooltipGeometry", and "TooltipAppearance"
// menu pseudo-items to add and configure tooltips.
// For details, see the included README.

class TF_TooltipListMenu : ListMenu {
  array<TF_Tooltip> tooltips;

  // Default settings:
  // - top left corner
  // - 30% of the screen width
  // - 1em horizontal margin and 0.5lh vertical margin
  // - white text using newsmallfont
  TF_Tooltip GetDefaults() {
    let tt = TF_Tooltip(new("TF_Tooltip"));
    tt.x = tt.y = 0.0;
    tt.w = 0.3;
    tt.xpad = 1.0;
    tt.ypad = 0.5;
    tt.scale = 1.0;
    tt.font = newsmallfont;
    tt.colour = Font.CR_WHITE;
    return tt;
  }

  override void Init(Menu parent, ListMenuDescriptor desc) {
    super.Init(parent, desc);
    let settings = GetDefaults();

    // If there's already a TooltipHolder in tail position, we've already been
    // initialized and just need to retrieve our saved tooltips from it.
    let tail = ListMenuItemTooltipHolder(desc.mItems[desc.mItems.size()-1]);
    if (tail) {
      tooltips.copy(tail.tooltips);
      return;
    }

    // Steal the descriptor's list of menu items, then rebuild it containing
    // only the items we want to display.
    array<ListMenuItem> items;
    items.Move(desc.mItems);

    // Start of tooltip block, i.e. index of the topmost menu item the next
    // tooltip will attach to.
    int startblock = -1;
    // Whether we're building a run of tooltips or processing non-tooltip menu
    // items.
    bool tooltip_mode = true;
    for (uint i = 0; i < items.size(); ++i) {
      if (items[i] is "ListMenuItemTooltip") {
        let tt = ListMenuItemTooltip(items[i]);
        if (tt.tooltip == "" && !tooltip_mode) {
          // Explicit marker that the above items should have no tooltips.
          startblock = desc.mItems.size();
        } else {
          AddTooltip(settings, startblock, desc.mItems.size()-1, tt.tooltip);
          tooltip_mode = true;
        }
      } else if (items[i] is "ListMenuItemTooltipGeometry") {
        ListMenuItemTooltipGeometry(items[i]).CopyTo(settings);
      } else if (items[i] is "ListMenuItemTooltipAppearance") {
        ListMenuItemTooltipAppearance(items[i]).CopyTo(settings);
      } else {
        if (tooltip_mode) {
          // Just finished a run of tooltips.
          startblock = desc.mItems.size();
          tooltip_mode = false;
        }
        desc.mItems.push(items[i]);
      }
    }

    // Store our tooltips inside the menu descriptor so we can recover them when
    // the menu is redisplayed.
    desc.mItems.push(ListMenuItemTooltipHolder(new("ListMenuItemTooltipHolder").Init(tooltips)));
  }

  TF_Tooltip AppendableTooltip(uint first, uint last) {
    if (tooltips.size() <= 0) return null;
    let tt = tooltips[tooltips.size()-1];
    if (tt.first == first) return tt;
    return null;
  }

  void AddTooltip(TF_Tooltip settings, uint first, uint last, string tooltip) {
    if (first < 0) ThrowAbortException("Tooltip must have at least one menu item preceding it!");
    let localtooltip = Stringtable.localize(tooltip);
    let tt = AppendableTooltip(first, last);
    if (tt) {
      // Existing tooltip that we're just appending to.
      tt.text = tt.text .. "\n" .. localtooltip;
      return;
    }
    // No existing tooltip for these menu entries, create a new one.
    tt = new("TF_Tooltip");
    tt.CopyFrom(settings);
    tt.first = first;
    tt.last = last;
    tt.text = localtooltip;
    tooltips.push(tt);
  }

  TF_Tooltip FindTooltipFor(int item) {
    // console.printf("FindTooltipFor(%d)", item);
    if (item < 0 || item >= mDesc.mItems.size()) return null;
    if (!mDesc.mItems[item].Selectable()) return null;
    for (uint i = 0; i < tooltips.size(); ++i) {
      if (tooltips[i].first <= item && item <= tooltips[i].last) {
        // console.printf("Found %d <= %d <= %d",
        //   tooltips[i].first, i, tooltips[i].last);
        return tooltips[i];
      }
    }
    return null;
  }

  override void Drawer() {
    super.Drawer();
    let tt = FindTooltipFor(mDesc.mSelectedItem);
    if (tt) tt.Draw();
  }
}

class ListMenuItemTooltipHolder : ListMenuItem {
  mixin TF_TooltipHolder;
}

class ListMenuItemTooltip : ListMenuItem {
  mixin TF_TooltipItem;
}

class ListMenuItemTooltipGeometry : ListMenuitem {
  mixin TF_TooltipGeometry;
}

class ListMenuItemTooltipAppearance : ListMenuitem {
  mixin TF_TooltipAppearance;
}
