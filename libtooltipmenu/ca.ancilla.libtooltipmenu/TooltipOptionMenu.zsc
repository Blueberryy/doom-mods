// TooltipOptionsMenu -- a drop-in replacement for OptionsMenu with tooltip support.
// Released under the MIT license; see COPYING.md for details.
//
// To use this, declare your option menu in MENUDEF as normal, but add:
//   class TF_TooltipOptionMenu
// to it. You can then use the "Tooltip", "TooltipBlockStart", and "TooltipBlockEnd"
// menu items, as in the following example:
//
// OptionMenu "ExampleTooltipOptions"
// {
//   class TFLIB_TooltipOptionMenu
//   Title "Example Tooltip Menu"
//
//   Slider "Kitten Amount", "sv_kitten_amount", 0, 100, 1, 0
//   Tooltip "The number of kittens to spawn."
//
//   Option "Spicy Kittens", "sv_kitten_spicy", "YesNo"
//   Tooltip "Whether kittens are spicy or not."
//   Tooltip "I don't know what that means, but isn't this multiline tooltip cool?"
//   Tooltip "Tooltips support \c[GREEN]escape sequences\c-, too."
//
//   TooltipBlockStart
//   Slider "Kitten Min Rating", "sv_kitten_min_rating", 1, 10, 1, 0
//   Slider "Kitten Max Rating", "sv_kitten_min_rating", 1, 10, 1, 0
//   Tooltip "Min/max ratings (out for 10) for kittens. Setting this to values other than 10 may destroy the fabric of spacetime."
//   Tooltip "The TooltipBlockStart/End means this tooltip sticks to both of the above Sliders."
//   TooltipBlockEnd
// }

class TF_Tooltip : Object ui {
  double x, y, w, xpad, ypad; // Geometry
  uint first, last; // First and last menuitems this applies to
  Font font;
  Color colour;
  TextureID texture;
  string text;

  void CopyFrom(TF_Tooltip settings) {
    self.x = settings.x;
    self.y = settings.y;
    self.w = settings.w;
    self.xpad = settings.xpad;
    self.ypad = settings.ypad;
    self.font = settings.font;
    self.colour = settings.colour;
    self.texture = settings.texture;
  }

  int GetX(uint width) {
    return (screen.GetWidth() - width) * self.x;
  }

  int GetY(uint height) {
    return (screen.GetHeight() - height) * self.y;
  }

  // TODO: support for arbitrary positioning & background textures using a
  // TooltipConfig menu pseudoitem.
  void Draw() {
    let em = self.font.GetCharWidth(0x6D);
    let lh = self.font.GetHeight();
    let nominal_width = screen.GetWidth() * self.w;
    let lines = self.font.BreakLines(self.text, nominal_width);

    // Calculate the real width of the tooltip. This may be less than the
    // nominal width if it's a short one-liner.
    uint actual_width = 0;
    for (uint i = 0; i < lines.count(); ++i) {
      actual_width = max(actual_width, self.font.StringWidth(lines.StringAt(i)));
    }
    actual_width += self.xpad * 2.0 * em;
    // Calculate the actual height based on the number of lines we wrapped it into
    // and the vertical margins.
    uint actual_height = self.font.GetHeight() * (self.ypad * 2.0 + lines.count());

    uint x = GetX(actual_width);
    uint y = GetY(actual_height);
    // Draw the background texture, if defined.
    Screen.DrawTexture(texture, true, x, y,
        DTA_LeftOffset, 0, DTA_TopOffset, 0,
        DTA_DestWidth, actual_width, DTA_DestHeight, actual_height);

    for (uint i = 0; i < lines.count(); ++i) {
      screen.DrawText(
        self.font, self.colour,
        x + self.xpad*em,
        y + i*lh + self.ypad*lh,
        lines.StringAt(i));
    }
  }
}

class TF_TooltipOptionMenu : OptionMenu {
  array<TF_Tooltip> tooltips;

  // Default settings:
  // - top left corner
  // - 30% of the screen width
  // - 1em horizontal margin and 0.5lh vertical margin
  // - white text using newsmallfont
  TF_Tooltip GetDefaults() {
    let tt = TF_Tooltip(new("TF_Tooltip"));
    tt.x = tt.y = 0.0;
    tt.w = 0.3;
    tt.xpad = 1.0;
    tt.ypad = 0.5;
    tt.font = newsmallfont;
    tt.colour = Font.CR_WHITE;
    return tt;
  }

  override void Init(Menu parent, OptionMenuDescriptor desc) {
    super.Init(parent, desc);
    let settings = GetDefaults();

    // Steal the descriptor's list of menu items, then rebuild it containing
    // only the items we want to display.
    array<OptionMenuItem> items;
    items.Move(desc.mItems);

    // Start of tooltip block, i.e. index of the topmost menu item the next
    // tooltip will attach to.
    int startblock = -1;
    // Whether we're building a run of tooltips or processing non-tooltip menu
    // items.
    bool tooltip_mode = true;
    for (uint i = 0; i < items.size(); ++i) {
      if (items[i] is "OptionMenuItemTooltip") {
        let tt = OptionMenuItemTooltip(items[i]);
        if (tt.tooltip == "" && !tooltip_mode) {
          // Explicit marker that the above items should have no tooltips.
          startblock = desc.mItems.size();
        } else {
          AddTooltip(settings, startblock, desc.mItems.size()-1, tt.tooltip);
          tooltip_mode = true;
        }
      } else if (items[i] is "OptionMenuItemTooltipGeometry") {
        OptionMenuItemTooltipGeometry(items[i]).CopyTo(settings);
      } else if (items[i] is "OptionMenuItemTooltipAppearance") {
        OptionMenuItemTooltipAppearance(items[i]).CopyTo(settings);
      } else {
        if (tooltip_mode) {
          // Just finished a run of tooltips.
          startblock = desc.mItems.size();
          tooltip_mode = false;
        }
        desc.mItems.push(items[i]);
      }
    }
  }

  TF_Tooltip AppendableTooltip(uint first, uint last) {
    if (tooltips.size() <= 0) return null;
    let tt = tooltips[tooltips.size()-1];
    if (tt.first == first && tt.last == last) return tt;
    return null;
  }

  void AddTooltip(TF_Tooltip settings, uint first, uint last, string tooltip) {
    if (first < 0) ThrowAbortException("Tooltip must have at least one menu item preceding it!");
    let tt = AppendableTooltip(first, last);
    if (tt) {
      // Existing tooltip that we're just appending to.
      tt.text = tt.text .. "\n" .. tooltip;
      return;
    }
    // No existing tooltip for these menu entries, create a new one.
    tt = new("TF_Tooltip");
    tt.CopyFrom(settings);
    tt.first = first;
    tt.last = last;
    tt.text = tooltip;
    tooltips.push(tt);
  }

  TF_Tooltip FindTooltipFor(int item) {
    for (uint i = 0; i < tooltips.size(); ++i) {
      if (tooltips[i].first <= item && item <= tooltips[i].last)
        return tooltips[i];
    }
    return null;
  }

  override void Drawer() {
    super.Drawer();
    let tt = FindTooltipFor(mDesc.mSelectedItem);
    if (tt) tt.Draw();
  }
}

class OptionMenuItemTooltip : OptionMenuItem {
  string tooltip;

  OptionMenuItemTooltip Init(string tooltip) {
    self.tooltip = tooltip.filter();
    super.init("", "");
    return self;
  }
}

class OptionMenuItemTooltipGeometry : OptionMenuitem {
  double x, y, w, xpad, ypad;

  OptionMenuItemTooltipGeometry Init(double x=-1.0, double y=-1.0, double w=-1.0, double xpad=-1.0, double ypad=-1.0) {
    self.x = x; self.y = y; self.w = w;
    self.xpad = xpad; self.ypad = ypad;
    return self;
  }

  void CopyTo(TF_Tooltip settings) {
    if (self.x >= 0) settings.x = self.x;
    if (self.y >= 0) settings.y = self.y;
    if (self.w >= 0) settings.w = self.w;
    if (self.xpad >= 0) settings.xpad = self.xpad;
    if (self.ypad >= 0) settings.ypad = self.ypad;
  }
}

class OptionMenuItemTooltipAppearance : OptionMenuitem {
  Font myfont;
  Color colour;
  TextureID texture;

  OptionMenuItemTooltipAppearance Init(string myfont="", string colour="", string texture="") {
    if (myfont != "") self.myfont = Font.GetFont(myfont);
    if (colour != "") self.colour = Font.FindFontColor(colour);
    if (texture != "") self.texture = TexMan.CheckForTexture(texture, TexMan.TYPE_ANY);
    return self;
  }

  void CopyTo(TF_Tooltip settings) {
    if (self.myfont) settings.font = self.myfont;
    if (self.colour) settings.colour = self.colour;
    if (self.texture) settings.texture = self.texture;
  }
}
