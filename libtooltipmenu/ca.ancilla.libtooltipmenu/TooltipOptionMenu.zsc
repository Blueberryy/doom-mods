// TooltipOptionsMenu -- a drop-in replacement for OptionsMenu with tooltip support.
// Released under the MIT license; see COPYING.md for details.
//
// To use this, declare your option menu in MENUDEF as normal, but add:
//   class TF_TooltipOptionMenu
// You can then use the "Tooltip", "TooltipGeometry", and "TooltipAppearance"
// menu pseudo-items to add and configure tooltips.
// For details, see the included README.

class TF_Tooltip : Object ui {
  double x, y, w, xpad, ypad; // Geometry
  uint first, last; // First and last menuitems this applies to
  Font font;
  Color colour;
  TextureID texture;
  string text;

  void CopyFrom(TF_Tooltip settings) {
    self.x = settings.x;
    self.y = settings.y;
    self.w = settings.w;
    self.xpad = settings.xpad;
    self.ypad = settings.ypad;
    self.font = settings.font;
    self.colour = settings.colour;
    self.texture = settings.texture;
  }

  int GetX(uint width) {
    return (screen.GetWidth() - width) * self.x;
  }

  int GetY(uint height) {
    return (screen.GetHeight() - height) * self.y;
  }

  void Draw() {
    let em = self.font.GetCharWidth(0x6D);
    let lh = self.font.GetHeight();
    let nominal_width = screen.GetWidth() * self.w;
    let lines = self.font.BreakLines(self.text, nominal_width);

    // Calculate the real width of the tooltip. This may be less than the
    // nominal width if it's a short one-liner.
    uint actual_width = 0;
    for (uint i = 0; i < lines.count(); ++i) {
      actual_width = max(actual_width, self.font.StringWidth(lines.StringAt(i)));
    }
    actual_width += self.xpad * 2.0 * em;
    // Calculate the actual height based on the number of lines we wrapped it into
    // and the vertical margins.
    uint actual_height = self.font.GetHeight() * (self.ypad * 2.0 + lines.count());

    uint x = GetX(actual_width);
    uint y = GetY(actual_height);
    // Draw the background texture, if defined.
    Screen.DrawTexture(texture, true, x, y,
        DTA_LeftOffset, 0, DTA_TopOffset, 0,
        DTA_DestWidth, actual_width, DTA_DestHeight, actual_height);

    for (uint i = 0; i < lines.count(); ++i) {
      screen.DrawText(
        self.font, self.colour,
        x + self.xpad*em,
        y + i*lh + self.ypad*lh,
        lines.StringAt(i));
    }
  }
}

class TF_TooltipOptionMenu : OptionMenu {
  array<TF_Tooltip> tooltips;

  // Default settings:
  // - top left corner
  // - 30% of the screen width
  // - 1em horizontal margin and 0.5lh vertical margin
  // - white text using newsmallfont
  TF_Tooltip GetDefaults() {
    let tt = TF_Tooltip(new("TF_Tooltip"));
    tt.x = tt.y = 0.0;
    tt.w = 0.3;
    tt.xpad = 1.0;
    tt.ypad = 0.5;
    tt.font = newsmallfont;
    tt.colour = Font.CR_WHITE;
    return tt;
  }

  override void Init(Menu parent, OptionMenuDescriptor desc) {
    super.Init(parent, desc);
    // console.printf("Init menu, items=%d", desc.mItems.size());
    let settings = GetDefaults();

    // If there's already a TooltipHolder in tail position, we've already been
    // initialized and just need to retrieve our saved tooltips from it.
    // for (uint i = 0; i < desc.mItems.size(); ++i) {
      // console.printf("Item: %s", desc.mItems[i].GetClassName());
    // }
    let tail = OptionMenuItemTooltipHolder(desc.mItems[desc.mItems.size()-1]);
    if (tail) {
      tooltips.copy(tail.tooltips);
      // console.printf("Cache hit, items=%d, tooltips=%d",
        // desc.mItems.size(), tooltips.size());
      return;
    }

    // Steal the descriptor's list of menu items, then rebuild it containing
    // only the items we want to display.
    array<OptionMenuItem> items;
    items.Move(desc.mItems);

    // Start of tooltip block, i.e. index of the topmost menu item the next
    // tooltip will attach to.
    int startblock = -1;
    // Whether we're building a run of tooltips or processing non-tooltip menu
    // items.
    bool tooltip_mode = true;
    for (uint i = 0; i < items.size(); ++i) {
      if (items[i] is "OptionMenuItemTooltip") {
        let tt = OptionMenuItemTooltip(items[i]);
        if (tt.tooltip == "" && !tooltip_mode) {
          // Explicit marker that the above items should have no tooltips.
          startblock = desc.mItems.size();
        } else {
          AddTooltip(settings, startblock, desc.mItems.size()-1, tt.tooltip);
          tooltip_mode = true;
        }
      } else if (items[i] is "OptionMenuItemTooltipGeometry") {
        OptionMenuItemTooltipGeometry(items[i]).CopyTo(settings);
      } else if (items[i] is "OptionMenuItemTooltipAppearance") {
        OptionMenuItemTooltipAppearance(items[i]).CopyTo(settings);
      } else {
        if (tooltip_mode) {
          // Just finished a run of tooltips.
          startblock = desc.mItems.size();
          tooltip_mode = false;
        }
        desc.mItems.push(items[i]);
      }
    }

    // Store our tooltips inside the menu descriptor so we can recover them when
    // the menu is redisplayed.
    desc.mItems.push(new("OptionMenuItemTooltipHolder").Init(tooltips));

    // console.printf("Init done, items=%d, tooltips=%d", desc.mItems.size(), tooltips.size());
  }

  TF_Tooltip AppendableTooltip(uint first, uint last) {
    if (tooltips.size() <= 0) return null;
    let tt = tooltips[tooltips.size()-1];
    if (tt.first == first) return tt;
    return null;
  }

  void AddTooltip(TF_Tooltip settings, uint first, uint last, string tooltip) {
    if (first < 0) ThrowAbortException("Tooltip must have at least one menu item preceding it!");
    let tt = AppendableTooltip(first, last);
    if (tt) {
      // Existing tooltip that we're just appending to.
      tt.text = tt.text .. "\n" .. tooltip;
      return;
    }
    // No existing tooltip for these menu entries, create a new one.
    tt = new("TF_Tooltip");
    tt.CopyFrom(settings);
    tt.first = first;
    tt.last = last;
    tt.text = tooltip;
    tooltips.push(tt);
  }

  TF_Tooltip FindTooltipFor(int item) {
    // console.printf("FindTooltipFor(%d)", item);
    if (item < 0 || item >= mDesc.mItems.size()) return null;
    if (!mDesc.mItems[item].Selectable()) return null;
    for (uint i = 0; i < tooltips.size(); ++i) {
      if (tooltips[i].first <= item && item <= tooltips[i].last) {
        // console.printf("Found %d <= %d <= %d",
        //   tooltips[i].first, i, tooltips[i].last);
        return tooltips[i];
      }
    }
    return null;
  }

  override void Drawer() {
    super.Drawer();
    let tt = FindTooltipFor(mDesc.mSelectedItem);
    if (tt) tt.Draw();
  }
}

class OptionMenuItemTooltipHolder : OptionMenuItem {
  array<TF_Tooltip> tooltips;

  OptionMenuItemTooltipHolder Init(array<TF_Tooltip> tts) {
    self.tooltips.copy(tts);
    return self;
  }

  override bool Selectable() { return false; }
}

class OptionMenuItemTooltip : OptionMenuItem {
  string tooltip;

  OptionMenuItemTooltip Init(string tooltip) {
    self.tooltip = tooltip.filter();
    return self;
  }
}

class OptionMenuItemTooltipGeometry : OptionMenuitem {
  double x, y, w, xpad, ypad;

  OptionMenuItemTooltipGeometry Init(double x=-1.0, double y=-1.0, double w=-1.0, double xpad=-1.0, double ypad=-1.0) {
    self.x = x; self.y = y; self.w = w;
    self.xpad = xpad; self.ypad = ypad;
    return self;
  }

  void CopyTo(TF_Tooltip settings) {
    if (self.x >= 0) settings.x = self.x;
    if (self.y >= 0) settings.y = self.y;
    if (self.w >= 0) settings.w = self.w;
    if (self.xpad >= 0) settings.xpad = self.xpad;
    if (self.ypad >= 0) settings.ypad = self.ypad;
  }
}

class OptionMenuItemTooltipAppearance : OptionMenuitem {
  Font myfont;
  Color colour;
  TextureID texture;

  OptionMenuItemTooltipAppearance Init(string myfont="", string colour="", string texture="") {
    if (myfont != "") self.myfont = Font.GetFont(myfont);
    if (colour != "") self.colour = Font.FindFontColor(colour);
    if (texture != "") self.texture = TexMan.CheckForTexture(texture, TexMan.TYPE_ANY);
    return self;
  }

  void CopyTo(TF_Tooltip settings) {
    if (self.myfont) settings.font = self.myfont;
    if (self.colour) settings.colour = self.colour;
    if (self.texture) settings.texture = self.texture;
  }
}
